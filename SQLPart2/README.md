# Day 01 — SQL Bootcamp

## Основы работы с множествами и объединениями (JOIN) в SQL

В этом проекте ты освоишь основные навыки работы с SQL: использование множеств и операторов объединения, создание подзапросов, сортировку по нескольким столбцам, а также разные виды соединений таблиц. Ты научишься находить пересечения и различия в данных, что важно для анализа и решения бизнес-задач.

Эти знания пригодятся при разработке запросов, аналитике данных и администрировании баз.

## Содержание
- [Chapter I](#chapter-i)
- [Введение](#введение)
- [Chapter II](#chapter-ii)
- [Рекомендации к выполнению этого проекта](#рекомендации-к-выполнению-этого-проекта)
- [Chapter III](#chapter-iii)
- [Задание 00 — Let's make UNION dance](#задание-00—lets-make-union-dance)
- [Задание 01 — UNION dance with subquery](#задание-01—union-dance-with-subquery)
- [Задание 02 — Duplicates or not duplicates](#задание-02—duplicates-or-not-duplicates)
- [Задание 03 — "Hidden" Insights](#задание-03—hidden-insights)
- [Задание 04 — Difference? Yep, let's find the difference between multisets](#задание-04—difference-yep-lets-find-the-difference-between-multisets)
- [Задание 05 — Did you hear about Cartesian Product?](#задание-05—did-you-hear-about-cartesian-product)
- [Задание 06 — Lets see on "Hidden" Insights](#задание-06—lets-see-on-hidden-insights)
- [Задание 07 — Just make a JOIN](#задание-07—just-make-a-join)
- [Задание 08 — Migrate JOIN to NATURAL JOIN](#задание-08—migrate-join-to-natural-join)
- [Задание 09 — IN versus EXISTS](#задание-09—in-versus-exists)
- [Задание 10 — Global JOIN](#задание-10—global-join)


## Chapter I
## Введение

Реляционные базы данных используют концепцию множеств в разных аспектах. Причём не только для операций объединения (UNION) или разности (MINUS) между множествами. Множества также отлично подходят для выполнения рекурсивных запросов.

В PostgreSQL доступны следующие операторы работы с множествами:

- UNION [ALL]
- EXCEPT [ALL]
- INTERSECT [ALL]

Ключевое слово ALL указывает на то, что в результате будут сохранены дублирующиеся строки.

Основные правила работы с множествами:

- Главный SQL-запрос определяет итоговые имена атрибутов для всего результата.
- В подчинённых SQL-запросах количество столбцов и их типы должны соответствовать структуре главного запроса.

Кроме того, множества в SQL полезны для вычисления некоторых специфических метрик в области Data Science — например, расстояния Жаккара между двумя объектами на основе имеющихся признаков данных.

## Chapter II
## Рекомендации к выполнению этого проекта

- Убедись, что ты работаешь с последней версией PostgreSQL.
- Ты можешь писать код (SQL-скрипты) в любой удобной IDE - это совершенно нормально.
- В директории должны оставаться только файлы, явно указанные в задании. Настрой .gitignore, чтобы избежать случайных ошибок.
- Убедись, что у тебя есть личная база данных и доступ к ней в твоем кластере PostgreSQL.
- Скачай [скрипт](./model.sql) с моделью базы данных и примени его к своей базе - сделать это можно либо через командную строку с помощью psql, либо через любую удобную IDE, например DataGrip от JetBrains или pgAdmin из сообщества PostgreSQL.
- В каждом задании внимательно ознакомься с разделами «Разрешено» и «Запрещено» - там перечислены допустимые опции базы данных, типы, конструкции SQL и другие важные ограничения.
- Да прибудет с тобой сила SQL!
- Приступай к работе - и пусть это будет увлекательно!

Перед выполнением заданий изучи логическую структуру модели базы данных ниже.

![schema](misc/images/schema.png)

1. **Таблица pizzeria** (справочник пиццерий)
   - поле id - первичный ключ
   - поле name - название пиццерии
   - поле rating - средний рейтинг пиццерии (от 0 до 5 баллов)

2. **Таблица person** (справочник клиентов, любящих пиццу)
   - поле id - первичный ключ
   - поле name - имя человека
   - поле age - возраст человека
   - поле gender - пол человека
   - поле address - адрес человека

3. **Таблица menu** (справочник с доступным меню и ценами на конкретные пиццы)
   - поле id - первичный ключ
   - поле pizzeria_id - внешний ключ на таблицу pizzeria
   - поле pizza_name - название пиццы в пиццерии
   - поле price - цена конкретной пиццы

4. **Таблица person_visits** (журнал посещений пиццерий)
   - поле id - первичный ключ
   - поле person_id - внешний ключ на таблицу person
   - поле pizzeria_id - внешний ключ на таблицу pizzeria
   - поле visit_date - дата посещения (например, 2022-01-01)

5. **Таблица person_order** (журнал заказов)
   - поле id - первичный ключ
   - поле person_id - внешний ключ на таблицу person
   - поле menu_id - внешний ключ на таблицу menu
   - поле order_date - дата заказа (например, 2022-01-01)

Посещения пиццерий и заказы - это разные сущности, между которыми нет прямой зависимости в данных. Например, клиент может находиться в одном ресторане, просто просматривая меню, и одновременно сделать заказ в другом ресторане по телефону или через мобильное приложение. Или другой вариант - быть дома и оформить заказ по телефону, не посещая заведение вовсе.

## Chapter III
## Задание 00 — Let's make UNION dance

| Задание 00: Let's make UNION dance | |
|-----------------------------------|--|
| Директория для загрузки решений | ex00 |
| Файлы для загрузки | `day01_ex00.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Напиши SQL-запрос, который объединит в один общий список идентификаторы меню и названия пицц из таблицы menu, а также идентификаторы и имена людей из таблицы person.

В итоговом результате столбцы должны называться так, как показано в примере ниже - сначала выборка по object_id, а затем по object_name.

| object_id | object_name |
|-----------|-------------|
| 1 | Anna |
| 1 | cheese pizza |
| ... | ... |

## Задание 01 — UNION dance with subquery

| Задание 01: UNION dance with subquery | |
|--------------------------------------|--|
| Директория для загрузки решений | ex01 |
| Файлы для загрузки | `day01_ex01.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Измени SQL-запрос из "Задания 00" следующим образом:

- Удали столбец object_id
- Измени порядок сортировки: сначала выведи данные из таблицы person (по object_name), затем из таблицы menu (также по object_name) - как показано в примере ниже

Сохрани дублирующиеся строки.

| object_name |
|-------------|
| Andrey |
| Anna |
| ... |
| cheese pizza |
| cheese pizza |
| ... |

## Задание 02 — Duplicates or not duplicates

| Задание 02: Duplicates or not duplicates | |
|-----------------------------------------|--|
| Директория для загрузки решений | ex02 |
| Файлы для загрузки | `day01_ex02.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |
| **Запрещено** | |
| Синтаксические конструкции SQL | `DISTINCT`, `GROUP BY`, `HAVING`, все виды `JOINs` |

Напиши SQL-запрос, который:

- Возвращает уникальные названия пицц из таблицы menu
- Сортирует результаты по столбцу pizza_name в порядке убывания

Перед началом работы обязательно ознакомься с разделом «Запрещено».

## Задание 03 — "Hidden" Insights

| Задание 03: "Hidden" Insights | |
|------------------------------|--|
| Директория для загрузки решений | ex03 |
| Файлы для загрузки | `day01_ex03.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |
| **Запрещено** | |
| Синтаксические конструкции SQL | все виды `JOINs` |

Напиши SQL-запрос, который:

Находит пересечение данных по:

- Дате заказа (order_date) и ID человека (person_id) из таблицы person_order
- Дате визита (visit_date) и ID человека (person_id) из таблицы person_visits

См. пример ниже. Проще говоря, тебе нужно найти идентификаторы людей, которые в один и тот же день и посетили заведение, и сделали заказ пиццы.

При этом результат следует отсортировать сначала по дате действия (action_date) в порядке возрастания, а затем по person_id — в порядке убывания.

| action_date | person_id |
|-------------|-----------|
| 2022-01-01 | 6 |
| 2022-01-01 | 2 |
| 2022-01-01 | 1 |
| 2022-01-03 | 7 |
| 2022-01-04 | 3 |
| ... | ... |

## Задание 04 — Difference? Yep, let's find the difference between multisets

| Задание 04: Difference? Yep, let's find the difference between multisets | |
|-------------------------------------------------------------------------|--|
| Директория для загрузки решений | ex04 |
| Файлы для загрузки | `day01_ex04.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |
| **Запрещено** | |
| Синтаксические конструкции SQL | все виды `JOINs` |

Напиши SQL-запрос, который вернет разницу (операция MINUS) по значениям столбца person_id между таблицами person_order и person_visits, при этом сохраняя дубликаты.

Запрос должен учитывать только записи за 7 января 2022 года

- Для таблицы person_order - где order_date = '2022-01-07'
- Для таблицы person_visits - где visit_date = '2022-01-07'

## Задание 05 — Did you hear about Cartesian Product?

| Задание 05: Did you hear about Cartesian Product? | |
|-------------------------------------------------|--|
| Директория для загрузки решений | ex05 |
| Файлы для загрузки | `day01_ex05.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Напиши SQL-запрос, который вернет все возможные комбинации записей из таблиц person и pizzeria.

В результате выполнения запроса сначала должны идти столбцы с идентификаторами из таблицы person, а затем — из таблицы pizzeria.

Изучи образец ожидаемого результата ниже.

Учитывай, названия столбцов в твоем результате могут отличаться от примера.

| person.id | person.name | age | gender | address | pizzeria.id | pizzeria.name | rating |
|-----------|-------------|-----|--------|---------|-------------|---------------|--------|
| 1 | Anna | 16 | female | Moscow | 1 | Pizza Hut | 4.6 |
| 1 | Anna | 16 | female | Moscow | 2 | Dominos | 4.3 |
| ... | ... | ... | ... | ... | ... | ... | ... |

## Задание 06 — Lets see on "Hidden" Insights

| Задание 06: Lets see on "Hidden" Insights | |
|------------------------------------------|--|
| Директория для загрузки решений | ex06 |
| Файлы для загрузки | `day01_ex06.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Вернемся к Заданию 03 и изменим SQL-запрос так, чтобы он возвращал имена людей вместо их идентификаторов.

Измени сортировку:

- Сначала по дате действия (action_date) в порядке возрастания
- Затем по имени человека (person_name) в порядке убывания

Изучи образец ожидаемого результата ниже.

| action_date | person_name |
|-------------|-------------|
| 2022-01-01 | Irina |
| 2022-01-01 | Anna |
| 2022-01-01 | Andrey |
| ... | ... |

## Задание 07 — Just make a JOIN

| Задание 07: Just make a JOIN | |
|------------------------------|--|
| Директория для загрузки решений | ex07 |
| Файлы для загрузки | `day01_ex07.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Напиши SQL-запрос, который возвращает:

- Дату заказа из таблицы person_order
- Имя человека, сделавшего заказ (из таблицы person), имя и возраст должны быть отформатированы, как показано в образце ниже

Сортирует результаты по обоим столбцам в порядке возрастания.

| order_date | person_information |
|------------|-------------------|
| 2022-01-01 | Andrey (age:21) |
| 2022-01-01 | Andrey (age:21) |
| 2022-01-01 | Anna (age:16) |
| ... | ... |

## Задание 08 — Migrate JOIN to NATURAL JOIN

| Задание 08: Migrate JOIN to NATURAL JOIN | |
|------------------------------------------|--|
| Директория для загрузки решений | ex08 |
| Файлы для загрузки | `day01_ex08.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |
| Синтаксические конструкции SQL | `NATURAL JOIN` |
| **Запрещено** | |
| Синтаксические конструкции SQL | все виды `JOINs` |

Перепиши SQL-запрос из Задания 07, используя конструкцию NATURAL JOIN. Результат должен совпадать с результатом из Задания 07.

## Задание 09 — IN versus EXISTS

| Задание 09: IN versus EXISTS | |
|------------------------------|--|
| Директория для загрузки решений | ex09 |
| Файлы для загрузки | `day01_ex09.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Напиши два SQL-запроса, которые возвращают список пиццерий, в которые не заходили люди: первый — с использованием оператора IN, второй — с использованием EXISTS.

## Задание 10 — Global JOIN

| Задание 10: Global JOIN | |
|-------------------------|--|
| Директория для загрузки решений | ex10 |
| Файлы для загрузки | `day01_ex10.sql` |
| **Разрешено** | |
| Язык | ANSI SQL |

Напиши SQL-запрос, который вернет список имен людей, заказавших пиццу в соответствующей пиццерии.

Возвращает список людей, заказавших пиццу, с указанием:

- Имени клиента
- Названия пиццы
- Названия пиццерии

Сортирует результаты по трем столбцам (все по возрастанию):

- person_name (имя клиента)
- pizza_name (название пиццы)
- pizzeria_name (название пиццерии)

Изучи образец ожидаемого результата ниже.

| person_name | pizza_name | pizzeria_name |
|-------------|------------|---------------|
| Andrey | cheese pizza | Dominos |
| Andrey | mushroom pizza | Dominos |
| Anna | cheese pizza | Pizza Hut |
| ... | ... | ... |
